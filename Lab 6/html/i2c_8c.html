<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AG_CB_Lab: src/Source_Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AG_CB_Lab
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2855980263c52be09af3085e80bd06a7.html">Source_Files</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">i2c.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the i2c functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
<code>#include &quot;sleep_routines.h&quot;</code><br />
<code>#include &quot;scheduler.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a467183b2f61bb98dce8b1b38af763455"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a467183b2f61bb98dce8b1b38af763455">i2c_bus_reset</a> (I2C_TypeDef *i2c_peripheral)</td></tr>
<tr class="memdesc:a467183b2f61bb98dce8b1b38af763455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reset the I2C state machines.  <a href="i2c_8c.html#a467183b2f61bb98dce8b1b38af763455">More...</a><br /></td></tr>
<tr class="separator:a467183b2f61bb98dce8b1b38af763455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2dbe4607903046b16b5342f01c2240"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a7d2dbe4607903046b16b5342f01c2240">i2c_start_interrupt</a> (void)</td></tr>
<tr class="memdesc:a7d2dbe4607903046b16b5342f01c2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the beginning of the interrupts for the i2c_start state machine. It doe not do anything that allows the IRQ Handler to move any interrupts in this part.  <a href="i2c_8c.html#a7d2dbe4607903046b16b5342f01c2240">More...</a><br /></td></tr>
<tr class="separator:a7d2dbe4607903046b16b5342f01c2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4915eb9bcfa0b50beb6c1536da145572"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a4915eb9bcfa0b50beb6c1536da145572">i2c_ack_interrupt</a> (void)</td></tr>
<tr class="memdesc:a4915eb9bcfa0b50beb6c1536da145572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the I2C interrupt handler will call upon receiving the I2C ACK interrupt.  <a href="i2c_8c.html#a4915eb9bcfa0b50beb6c1536da145572">More...</a><br /></td></tr>
<tr class="separator:a4915eb9bcfa0b50beb6c1536da145572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d8cf15c864da83a16e5b05527327b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a35d8cf15c864da83a16e5b05527327b1">i2c_nack_interrupt</a> (void)</td></tr>
<tr class="memdesc:a35d8cf15c864da83a16e5b05527327b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the I2C interrupt handler will call upon receiving the I2C NACK interrupt.  <a href="i2c_8c.html#a35d8cf15c864da83a16e5b05527327b1">More...</a><br /></td></tr>
<tr class="separator:a35d8cf15c864da83a16e5b05527327b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3535d8cfb198b6e1eb430be8c99405"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a1a3535d8cfb198b6e1eb430be8c99405">i2c_mstop_interrupt</a> (void)</td></tr>
<tr class="memdesc:a1a3535d8cfb198b6e1eb430be8c99405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the I2C interrupt handler will call upon receiving the I2C MSTOP interrupt.  <a href="i2c_8c.html#a1a3535d8cfb198b6e1eb430be8c99405">More...</a><br /></td></tr>
<tr class="separator:a1a3535d8cfb198b6e1eb430be8c99405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e8e2df5fa16f8c5a160e1d6d2623ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a61e8e2df5fa16f8c5a160e1d6d2623ab">i2c_rxdatav_interrupt</a> (void)</td></tr>
<tr class="memdesc:a61e8e2df5fa16f8c5a160e1d6d2623ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the I2C interrupt handler will call upon receiving the I2C RXDATAV interrupt.  <a href="i2c_8c.html#a61e8e2df5fa16f8c5a160e1d6d2623ab">More...</a><br /></td></tr>
<tr class="separator:a61e8e2df5fa16f8c5a160e1d6d2623ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80996309c72b30532a98e16726801d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a80996309c72b30532a98e16726801d34">i2c_open</a> (I2C_TypeDef *i2c_peripheral, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_open_peripheral_struct)</td></tr>
<tr class="memdesc:a80996309c72b30532a98e16726801d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to open an i2c bus.  <a href="i2c_8c.html#a80996309c72b30532a98e16726801d34">More...</a><br /></td></tr>
<tr class="separator:a80996309c72b30532a98e16726801d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ handler for I2C0.  <a href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">More...</a><br /></td></tr>
<tr class="separator:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45e5675f6f4e6e1dee2273baf245219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">I2C1_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:ac45e5675f6f4e6e1dee2273baf245219"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ handler for I2C1.  <a href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">More...</a><br /></td></tr>
<tr class="separator:ac45e5675f6f4e6e1dee2273baf245219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bcf3ef4a345716e5d28838149f64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aa33bcf3ef4a345716e5d28838149f64f">i2c_start</a> (I2C_TypeDef *i2c_peripheral, uint32_t slave_address, uint32_t command, uint32_t *read_value, uint32_t callback)</td></tr>
<tr class="memdesc:aa33bcf3ef4a345716e5d28838149f64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to start an I2C read or write operation.  <a href="i2c_8c.html#aa33bcf3ef4a345716e5d28838149f64f">More...</a><br /></td></tr>
<tr class="separator:aa33bcf3ef4a345716e5d28838149f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae8d157d7fae5c0203cfc842940289a0f"><td class="memItemLeft" align="right" valign="top"><a id="ae8d157d7fae5c0203cfc842940289a0f"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_peripheral_state</b></td></tr>
<tr class="separator:ae8d157d7fae5c0203cfc842940289a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a94898acebf1a4a4b858be4a3394b"><td class="memItemLeft" align="right" valign="top"><a id="a122a94898acebf1a4a4b858be4a3394b"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_read_cb</b></td></tr>
<tr class="separator:a122a94898acebf1a4a4b858be4a3394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the i2c functions. </p>
<dl class="section author"><dt>Author</dt><dd>Aditya Gopalan </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 29th, 2020 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e817e99d2a59e5f48e4ff0c79e7eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e817e99d2a59e5f48e4ff0c79e7eef5">&#9670;&nbsp;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRQ handler for I2C0. </p>
<p>This is an IRQ handler for I2C0.</p>
<dl class="section note"><dt>Note</dt><dd>This is currently configured to handle the interrupts for ACK, NACK, RXDATAV, and MSTOP. Interrupts are enabled in the i2c_open function. </dd></dl>

</div>
</div>
<a id="ac45e5675f6f4e6e1dee2273baf245219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45e5675f6f4e6e1dee2273baf245219">&#9670;&nbsp;</a></span>I2C1_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRQ handler for I2C1. </p>
<p>This is an IRQ handler for I2C1.</p>
<dl class="section note"><dt>Note</dt><dd>This is currently configured to handle the interrupts for ACK, NACK, RXDATAV, and MSTOP. Interrupts are enabled in the i2c_open function. </dd></dl>

</div>
</div>
<a id="a4915eb9bcfa0b50beb6c1536da145572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4915eb9bcfa0b50beb6c1536da145572">&#9670;&nbsp;</a></span>i2c_ack_interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_ack_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that the I2C interrupt handler will call upon receiving the I2C ACK interrupt. </p>
<p>This function defines the behavior of the state machine in each state when an ACK is received. </p>

</div>
</div>
<a id="a467183b2f61bb98dce8b1b38af763455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467183b2f61bb98dce8b1b38af763455">&#9670;&nbsp;</a></span>i2c_bus_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_bus_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c_peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to reset the I2C state machines. </p>
<p>This function resets the state machines of both the Pearl Gecko and external I2C devices connected to the bus.</p>
<dl class="section note"><dt>Note</dt><dd>This function resets the peripheral I2C devices by NACKing 9 times by manually clocking the SCK pin while leaving SDA in its default asserted state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_peripheral</td><td>Pointer to the base peripheral address of the I2C peripheral being used. The Pearl Gecko has its I2C peripherals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a3535d8cfb198b6e1eb430be8c99405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3535d8cfb198b6e1eb430be8c99405">&#9670;&nbsp;</a></span>i2c_mstop_interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_mstop_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that the I2C interrupt handler will call upon receiving the I2C MSTOP interrupt. </p>
<p>This function defines the behavior of the state machine in each state when a STOP condition has been successfully transmitted. </p>

</div>
</div>
<a id="a35d8cf15c864da83a16e5b05527327b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d8cf15c864da83a16e5b05527327b1">&#9670;&nbsp;</a></span>i2c_nack_interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_nack_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that the I2C interrupt handler will call upon receiving the I2C NACK interrupt. </p>
<p>This function defines the behavior of the state machine in each state when a NACK is received. </p>

</div>
</div>
<a id="a80996309c72b30532a98e16726801d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80996309c72b30532a98e16726801d34">&#9670;&nbsp;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c_peripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_open_peripheral_struct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to open an i2c bus. </p>
<p>This routine initializes an i2c bus and sets its state to IDLE. This also sets all the clock frequencies and initialize the I2C peripheral struct.</p>
<dl class="section note"><dt>Note</dt><dd>This function enables the interrupt flags ACK, NACK, RXDATATV and MSTOP.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_peripheral</td><td>Pointer to the base peripheral address of the I2C peripheral being used. The Pearl Gecko has 2 I2C peripherals.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_open_peripheral_struct</td><td>The struct that this routine will use to configure the I2C bus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e8e2df5fa16f8c5a160e1d6d2623ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e8e2df5fa16f8c5a160e1d6d2623ab">&#9670;&nbsp;</a></span>i2c_rxdatav_interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_rxdatav_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that the I2C interrupt handler will call upon receiving the I2C RXDATAV interrupt. </p>
<p>This function defines the behavior of the state machine in each state when data becomes available in the receive buffer. </p>

</div>
</div>
<a id="aa33bcf3ef4a345716e5d28838149f64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33bcf3ef4a345716e5d28838149f64f">&#9670;&nbsp;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c_peripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>read_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to start an I2C read or write operation. </p>
<p>Initializes the I2C sensor which stores the state of the I2C operation. All information required by the I2C state machine interacts with this I2C sensor struct. Once the temperature sensor is initialized, this function initiates the I2C operation by entering the first state of the state machine</p>
<dl class="section note"><dt>Note</dt><dd>This function must only be called if the state of the I2C peripheral and the state of the I2C state machine are both in the idle state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_peripheral</td><td>Pointer to the base peripheral address of the I2C peripheral being used. The Pearl Gecko has 2 I2C peripherals.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slave_address</td><td>The 32 bit i2c slave device address of the peripheral device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_value</td><td>32 bit parameter indicating the value of the sensor whether to start a read or write command</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The 32 bit command code to write to the peripheral device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The scheduler callback function associated with a completed i2c operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d2dbe4607903046b16b5342f01c2240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2dbe4607903046b16b5342f01c2240">&#9670;&nbsp;</a></span>i2c_start_interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_start_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is the beginning of the interrupts for the i2c_start state machine. It doe not do anything that allows the IRQ Handler to move any interrupts in this part. </p>
<p>If it manages to get into this interrupt, it will break and there are asserts at the end when it gets to the stop interrupt section of the function </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
